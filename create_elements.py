# This file was *autogenerated* from the file /Users/mgarcia/PPL/PPL_example/create_elements.sage.
#from sage.all_cmdline import *   # import sage library
#_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from sage.libs.ppl import *
import time


#----------------------------------------------------------------------------------------------#
def create_elements(LE):
	"""
	Generate elements of a partition from a list of linear expressions.
	input:	LE	Linear Expressions      list of ppl.Linear_Expressions	
											
	output:	E	Elements                list of ppl.NNC_Polyhedron
	"""
    
	print 'LE=\n',LE
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	
	# Starting time
	creation_time = time.time()

	# Element list
	E = []
	

	# We will check the first linear expression in the input list
	first_le = True
	for le in LE:
		
		# Constraints definition
		#ceq = le == _sage_const_0 					# Equality ppl.constraint
		#cbg = le > _sage_const_0 					# Bigger than zero ppl.constraint
		#csm = le < _sage_const_0 					# Smaller than zero ppl.constraint
		ceq = le == 0 					# Equality ppl.constraint
		cbg = le > 0 					# Bigger than zero ppl.constraint
		csm = le < 0 					# Smaller than zero ppl.constraint

		
		#print 'ceq=',ceq
		#print 'cbg=',cbg
		#print 'csm=',csm


		# Construct polyhedra with the constraints
		peq = NNC_Polyhedron(ceq)
		pbg = NNC_Polyhedron(cbg)
		psm = NNC_Polyhedron(csm)
		
		##print 'peq=',peq
		#print 'peq.constraints()=',peq.constraints()
		#print 'pbg=',pbg
		#print 'pbg.constraints()=',pbg.constraints()
		#print 'psm=',psm
		#print 'psm.constraints()=',psm.constraints()

		if first_le == True:

			# Add polyhedra to the element list
			E.append(peq)
			E.append(pbg)
			E.append(psm)
			#print 'New elements:'
			#print '   peq=',peq.constraints()
			#print '   pbg=',pbg.constraints()
			#print '   psm=',psm.constraints()

			# We will not check the first linear expression anymore
			first_le = False

		else:
			# Duplicate de element list
			aux_E = []
			# SPLIT ELEMENTS
			# Check if the elements are divided by the new linear expression
			for e in E:
				# the element is divided in case intersections with cbg and csm are different from emptiness
				# element intersected with pbg
				new_ebg = NNC_Polyhedron(e)
				#print new_ebg
				#print 'new_ebg=',new_ebg.constraints()
				new_ebg.intersection_assign(pbg)
				#print 'new_ebg after intersection with ',pbg.constraints(),' =',new_ebg.constraints()
                    
				if (new_ebg.is_empty() == False) and (new_ebg != e):
					# element intersected with psm
					new_esm = NNC_Polyhedron(e)
					new_esm.intersection_assign(psm)
                    
					if new_esm.is_empty() == False:
						# in the case the element is divided, this one disappears and three new elements are defined
						#print 'Element ',e.constraints(),' divided.'
						new_eeq = NNC_Polyhedron(e)
						new_eeq.intersection_assign(peq)
						aux_E.append(new_ebg)
						aux_E.append(new_esm)
						aux_E.append(new_eeq)
						#print 'New elements:'
						#print '   new_ebg=',new_ebg.constraints()
						#print '   new_esm=',new_esm.constraints()
						#print '   new_eeq=',new_eeq.constraints()

				else:
					# the element is not divided
					#print ' Element',e.constraints(), 'not divided.'
					aux_E.append(e)

			E = aux_E[:]
                
	creation_time = time.time() - creation_time

	return E,creation_time



#----------------------------------------------------------------------------------------------#
def get_regions_and_faces(E):

	dim = E[0].space_dimension()
	
	RG = []
	F = []

	for element in E:
		if element.affine_dimension() == dim:
			RG.append(element)
		else:
			F.append(element)

	return RG,F




#----------------------------------------------------------------------------------------------#
def create_new_elements(E,LE):
	"""
		Generate elements of a partition of elements from a list of linear expressions.
		input:	E		Elements					list of ppl.NNC_Polyhedron
				LE		Linear Expressions			list of ppl.Linear_Expressions
		
		output:	new_E	Elements					list of ppl.NNC_Polyhedron
		"""
    
	print 'LE=\n',LE
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	#print '****************************************************************************************************************************************'
	
	# Starting time
	creation_time = time.time()
	
	# Element list
	new_E = E
	
	
	# We will check the first linear expression in the input list
	#	first_le = True
	for le in LE:
		
		# Constraints definition
		#ceq = le == _sage_const_0 					# Equality ppl.constraint
		#cbg = le > _sage_const_0 					# Bigger than zero ppl.constraint
		#csm = le < _sage_const_0 					# Smaller than zero ppl.constraint
		ceq = le == 0 					# Equality ppl.constraint
		cbg = le > 0 					# Bigger than zero ppl.constraint
		csm = le < 0 					# Smaller than zero ppl.constraint
		
		
		#print 'ceq=',ceq
		#print 'cbg=',cbg
		#print 'csm=',csm
		
		
		# Construct polyhedra with the constraints
		peq = NNC_Polyhedron(ceq)
		pbg = NNC_Polyhedron(cbg)
		psm = NNC_Polyhedron(csm)
		
		##print 'peq=',peq
		#print 'peq.constraints()=',peq.constraints()
		#print 'pbg=',pbg
		#print 'pbg.constraints()=',pbg.constraints()
		#print 'psm=',psm
		#print 'psm.constraints()=',psm.constraints()
		
#		if first_le == True:
#			
#			# Add polyhedra to the element list
#			new_E.append(peq)
#			new_E.append(pbg)
#			new_E.append(psm)
#			#print 'New elements:'
#			#print '   peq=',peq.constraints()
#			#print '   pbg=',pbg.constraints()
#			#print '   psm=',psm.constraints()
#			
#			# We will not check the first linear expression anymore
#			first_le = False
#		
#		else:
		# Duplicate de element list
		aux_E = []
		# SPLIT ELEMENTS
		# Check if the elements are divided by the new linear expression
		for e in new_E:
			# the element is divided in case intersections with cbg and csm are different from emptiness
			# element intersected with pbg
			new_ebg = NNC_Polyhedron(e)
			#print new_ebg
			#print 'new_ebg=',new_ebg.constraints()
			new_ebg.intersection_assign(pbg)
			#print 'new_ebg after intersection with ',pbg.constraints(),' =',new_ebg.constraints()
			
			if (new_ebg.is_empty() == False) and (new_ebg != e):
				# element intersected with psm
				new_esm = NNC_Polyhedron(e)
				new_esm.intersection_assign(psm)
				
				if new_esm.is_empty() == False:
					# in the case the element is divided, this one disappears and three new elements are defined
					#print 'Element ',e.constraints(),' divided.'
					new_eeq = NNC_Polyhedron(e)
					new_eeq.intersection_assign(peq)
					aux_E.append(new_ebg)
					aux_E.append(new_esm)
					aux_E.append(new_eeq)
					#print 'New elements:'
					#print '   new_ebg=',new_ebg.constraints()
					#print '   new_esm=',new_esm.constraints()
					#print '   new_eeq=',new_eeq.constraints()
			
			else:
				# the element is not divided
				#print ' Element',e.constraints(), 'not divided.'
				aux_E.append(e)
		
		new_E = aux_E[:]

	creation_time = time.time() - creation_time
	
	return new_E,creation_time









